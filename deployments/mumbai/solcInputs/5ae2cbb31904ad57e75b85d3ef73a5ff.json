{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Mining.sol": {
      "content": "/**\r\n *Submitted for verification at BscScan.com on 2022-12-12\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport '@openzeppelin/contracts/utils/Context.sol';\r\n\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  // function isPresaleClaimed(address account) external view returns (bool);\r\n}\r\n\r\ncontract Mining is Context, Ownable {\r\n\r\n  uint256 private BONES_TO_HATCH_1MINERS = 1080000; //for final version should be seconds in a day\r\n  uint256 private PSN = 10000;\r\n  uint256 private PSNH = 5000;\r\n  uint256 private devFeeVal = 2;\r\n  bool private initialized = false;\r\n  address payable private recAdd = payable(0xAEba95a79411d88C7c108BEbCC2A8eaa5143A7f9);\r\n  mapping(address => uint256) private hatcheryMiners;\r\n  mapping(address => uint256) private claimedBones;\r\n  mapping(address => uint256) private lastHatch;\r\n  mapping(address => address) private referrals;\r\n  uint256 private marketBones;\r\n  uint8 public tradingState = 0;\r\n  IERC20 token;\r\n\r\n  constructor(address _owner, address _token) {\r\n    setToken(_token);\r\n    transferOwnership(_owner);\r\n  }\r\n\r\n  modifier canTrade() {\r\n    // if (tradingState == 1)\r\n    //   require(token.isPresaleClaimed(_msgSender()) || owner() == _msgSender(), 'only presale users');\r\n\r\n    if (tradingState == 0) require(owner() == _msgSender(), 'trades are not enabled');\r\n\r\n    require(owner() == _msgSender() || token.balanceOf(_msgSender()) != 0, 'should be a MINE holder');\r\n\r\n    _;\r\n  }\r\n\r\n  function setTradingState(uint8 _tradingState) public onlyOwner {\r\n    require(_tradingState < 3, 'trading state should be 0:only owner, 1:whitelisted, 2:public');\r\n    tradingState = _tradingState;\r\n  }\r\n\r\n  function setToken(address _token) public onlyOwner {\r\n    require(_token != address(0), 'invalid token address');\r\n    token = IERC20(_token);\r\n  }\r\n\r\n  function hatchBones() public canTrade {\r\n    require(initialized, 'not initilized');\r\n\r\n    uint256 bonesUsed = getMyBones(msg.sender);\r\n    uint256 newMiners = bonesUsed / BONES_TO_HATCH_1MINERS;\r\n    hatcheryMiners[msg.sender] = hatcheryMiners[msg.sender] + newMiners;\r\n    claimedBones[msg.sender] = 0;\r\n    lastHatch[msg.sender] = block.timestamp;\r\n\r\n    //boost market to nerf miners hoarding\r\n    marketBones = marketBones + (bonesUsed/5);\r\n  }\r\n\r\n  function sellBones() public canTrade {\r\n    require(initialized, 'not initilized');\r\n    uint256 hasBones = getMyBones(msg.sender);\r\n    uint256 boneValue = calculateBoneSell(hasBones);\r\n    uint256 fee = devFee(boneValue);\r\n    claimedBones[msg.sender] = 0;\r\n    lastHatch[msg.sender] = block.timestamp;\r\n    marketBones = marketBones + hasBones;\r\n    recAdd.transfer(fee);\r\n    payable(msg.sender).transfer(boneValue - fee);\r\n  }\r\n\r\n  function beanRewards(address adr) public view returns (uint256) {\r\n    uint256 hasBones = getMyBones(adr);\r\n    uint256 boneValue = calculateBoneSell(hasBones);\r\n    return boneValue;\r\n  }\r\n\r\n  function buyBones() public payable canTrade {\r\n    require(initialized, 'not initilized');\r\n    uint256 bonesBought = calculateBoneBuy(msg.value, (address(this).balance - msg.value));\r\n    // uint256 bonesBought = 10800000;\r\n    bonesBought = bonesBought - devFee(bonesBought);\r\n    uint256 fee = devFee(msg.value);\r\n    recAdd.transfer(fee);\r\n    claimedBones[msg.sender] = claimedBones[msg.sender] + bonesBought;\r\n    hatchBones();\r\n  }\r\n\r\n  function calculateTrade(\r\n    uint256 rt,\r\n    uint256 rs,\r\n    uint256 bs\r\n  ) private view returns (uint256) {\r\n    return\r\n        PSN * bs/PSNH + (PSN * rs + PSNH * rt)/rt;\r\n  }\r\n\r\n  function calculateBoneSell(uint256 bones) public view returns (uint256) {\r\n    return calculateTrade(bones, marketBones, address(this).balance);\r\n  }\r\n\r\n  function calculateBoneBuy(uint256 eth, uint256 contractBalance) public view returns (uint256) {\r\n    return calculateTrade(eth, contractBalance, marketBones);\r\n  }\r\n\r\n  function calculateBoneBuySimple(uint256 eth) public view returns (uint256) {\r\n    return calculateBoneBuy(eth, address(this).balance);\r\n  }\r\n\r\n  function devFee(uint256 amount) private view returns (uint256) {\r\n    return amount * devFeeVal/100;\r\n  }\r\n\r\n  function seedMarket() public payable onlyOwner {\r\n    require(marketBones == 0);\r\n    initialized = true;\r\n    marketBones = 108000000000;\r\n  }\r\n\r\n  function getBalance() public view returns (uint256) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function getMyMiners(address adr) public view returns (uint256) {\r\n    return hatcheryMiners[adr];\r\n  }\r\n\r\n  function getMyBones(address adr) public view returns (uint256) {\r\n    return claimedBones[adr] + getBonesSinceLastHatch(adr);\r\n  }\r\n\r\n  function getBonesSinceLastHatch(address adr) public view returns (uint256) {\r\n    uint256 secondsPassed = min(BONES_TO_HATCH_1MINERS, (block.timestamp - lastHatch[adr]));\r\n    return secondsPassed * hatcheryMiners[adr];\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}