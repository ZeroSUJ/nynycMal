{
  "language": "Solidity",
  "sources": {
    "contracts/Mining.sol": {
      "content": "/**\r\n *Submitted for verification at BscScan.com on 2022-12-12\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\nlibrary SafeMath {\r\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      uint256 c = a + b;\r\n      if (c < a) return (false, 0);\r\n      return (true, c);\r\n    }\r\n  }\r\n\r\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b > a) return (false, 0);\r\n      return (true, a - b);\r\n    }\r\n  }\r\n\r\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (a == 0) return (true, 0);\r\n      uint256 c = a * b;\r\n      if (c / a != b) return (false, 0);\r\n      return (true, c);\r\n    }\r\n  }\r\n\r\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b == 0) return (false, 0);\r\n      return (true, a / b);\r\n    }\r\n  }\r\n\r\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b == 0) return (false, 0);\r\n      return (true, a % b);\r\n    }\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a + b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a * b;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a % b;\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b <= a, errorMessage);\r\n      return a - b;\r\n    }\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b > 0, errorMessage);\r\n      return a / b;\r\n    }\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b > 0, errorMessage);\r\n      return a % b;\r\n    }\r\n  }\r\n}\r\n\r\npragma solidity ^0.8.20;\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function isPresaleClaimed(address account) external view returns (bool);\r\n}\r\n\r\ncontract Mining is Context, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 private BONES_TO_HATCH_1MINERS = 1080000; //for final version should be seconds in a day\r\n  uint256 private PSN = 10000;\r\n  uint256 private PSNH = 5000;\r\n  uint256 private devFeeVal = 2;\r\n  bool private initialized = false;\r\n  address payable private recAdd = payable(0x0406dbBF7B62f79F8d889F30cC1F0E9191c404D4);\r\n  mapping(address => uint256) private hatcheryMiners;\r\n  mapping(address => uint256) private claimedBones;\r\n  mapping(address => uint256) private lastHatch;\r\n  mapping(address => address) private referrals;\r\n  uint256 private marketBones;\r\n  uint8 public tradingState = 0;\r\n  IERC20 token;\r\n\r\n  constructor(address _owner, address _token) {\r\n    setToken(_token);\r\n    transferOwnership(_owner);\r\n  }\r\n\r\n  modifier canTrade() {\r\n    // if (tradingState == 1)\r\n    //   require(token.isPresaleClaimed(_msgSender()) || owner() == _msgSender(), 'only presale users');\r\n\r\n    if (tradingState == 0) require(owner() == _msgSender(), 'trades are not enabled');\r\n\r\n    require(owner() == _msgSender() || token.balanceOf(_msgSender()) != 0, 'should be a MINE holder');\r\n\r\n    _;\r\n  }\r\n\r\n  function setTradingState(uint8 _tradingState) public onlyOwner {\r\n    require(_tradingState < 3, 'trading state should be 0:only owner, 1:whitelisted, 2:public');\r\n    tradingState = _tradingState;\r\n  }\r\n\r\n  function setToken(address _token) public onlyOwner {\r\n    require(_token != address(0), 'invalid token address');\r\n    token = IERC20(_token);\r\n  }\r\n\r\n  function hatchBones() public canTrade {\r\n    require(initialized, 'not initilized');\r\n\r\n    uint256 bonesUsed = getMyBones(msg.sender);\r\n    uint256 newMiners = SafeMath.div(bonesUsed, BONES_TO_HATCH_1MINERS);\r\n    hatcheryMiners[msg.sender] = SafeMath.add(hatcheryMiners[msg.sender], newMiners);\r\n    claimedBones[msg.sender] = 0;\r\n    lastHatch[msg.sender] = block.timestamp;\r\n\r\n    //boost market to nerf miners hoarding\r\n    marketBones = SafeMath.add(marketBones, SafeMath.div(bonesUsed, 5));\r\n  }\r\n\r\n  function sellBones() public canTrade {\r\n    require(initialized, 'not initilized');\r\n    uint256 hasBones = getMyBones(msg.sender);\r\n    uint256 boneValue = calculateBoneSell(hasBones);\r\n    uint256 fee = devFee(boneValue);\r\n    claimedBones[msg.sender] = 0;\r\n    lastHatch[msg.sender] = block.timestamp;\r\n    marketBones = SafeMath.add(marketBones, hasBones);\r\n    recAdd.transfer(fee);\r\n    payable(msg.sender).transfer(SafeMath.sub(boneValue, fee));\r\n  }\r\n\r\n  function beanRewards(address adr) public view returns (uint256) {\r\n    uint256 hasBones = getMyBones(adr);\r\n    uint256 boneValue = calculateBoneSell(hasBones);\r\n    return boneValue;\r\n  }\r\n\r\n  function buyBones() public payable canTrade {\r\n    require(initialized, 'not initilized');\r\n    uint256 bonesBought = calculateBoneBuy(msg.value, SafeMath.sub(address(this).balance, msg.value));\r\n    bonesBought = SafeMath.sub(bonesBought, devFee(bonesBought));\r\n    uint256 fee = devFee(msg.value);\r\n    recAdd.transfer(fee);\r\n    claimedBones[msg.sender] = SafeMath.add(claimedBones[msg.sender], bonesBought);\r\n    hatchBones();\r\n  }\r\n\r\n  function calculateTrade(\r\n    uint256 rt,\r\n    uint256 rs,\r\n    uint256 bs\r\n  ) private view returns (uint256) {\r\n    require(rt != 0, \"Division must not be 0\");\r\n    return\r\n      SafeMath.div(\r\n        SafeMath.mul(PSN, bs),\r\n        SafeMath.add(PSNH, SafeMath.div(SafeMath.add(SafeMath.mul(PSN, rs), SafeMath.mul(PSNH, rt)), rt))\r\n      );\r\n  }\r\n\r\n  function calculateBoneSell(uint256 bones) public view returns (uint256) {\r\n    return calculateTrade(bones, marketBones, address(this).balance);\r\n  }\r\n\r\n  function calculateBoneBuy(uint256 eth, uint256 contractBalance) public view returns (uint256) {\r\n    return calculateTrade(eth, contractBalance, marketBones);\r\n  }\r\n\r\n  function calculateBoneBuySimple(uint256 eth) public view returns (uint256) {\r\n    return calculateBoneBuy(eth, address(this).balance);\r\n  }\r\n\r\n  function devFee(uint256 amount) private view returns (uint256) {\r\n    return SafeMath.div(SafeMath.mul(amount, devFeeVal), 100);\r\n  }\r\n\r\n  function seedMarket() public payable onlyOwner {\r\n    require(marketBones == 0, \"Marketbones must be 0\");\r\n    initialized = true;\r\n    marketBones = 108000000000;\r\n  }\r\n\r\n  function getBalance() public view returns (uint256) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function getMyMiners(address adr) public view returns (uint256) {\r\n    return hatcheryMiners[adr];\r\n  }\r\n\r\n  function getMyBones(address adr) public view returns (uint256) {\r\n    return SafeMath.add(claimedBones[adr], getBonesSinceLastHatch(adr));\r\n  }\r\n\r\n  function getBonesSinceLastHatch(address adr) public view returns (uint256) {\r\n    uint256 secondsPassed = min(BONES_TO_HATCH_1MINERS, SafeMath.sub(block.timestamp, lastHatch[adr]));\r\n    return SafeMath.mul(secondsPassed, hatcheryMiners[adr]);\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}